{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<style>
    .grid {
        opacity: 0.5;
        color: silver;
    }

    #table_div {
        overflow: auto;
        height: 800px
    }
</style>
<script src="https://d3js.org/d3.v7.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css" rel="stylesheet"
      integrity="sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-U1DAWAznBHeqEIlVSCgzq+c9gqGAJn5c/t99JyeKa9xxaYpSvHU5awsuZVVFIhvj"
        crossorigin="anonymous"></script>
{#<form>#}
{#    <label><input type="radio" name="mode" value="cluster" checked> Dendrogram</label>#}
{#    <label><input type="radio" name="mode" value="tree"> Tree</label>#}
{#</form>#}
<body>
<div class="container-fluid">
    <div class="row">
        <div id="menu_div" class="col-12">
            menu
            <svg id="menu_svg" width="100%">
            </svg>
        </div>
    </div>
    <div class="row">
        <div id="time_div" class="col-12">
            timeline
            <svg id="time_svg" width="100%">

            </svg>
        </div>
    </div>
    <div class="row">
        <div id='table_div' class="col-4">
            table
            <br/>
            <svg id="table_svg" height="2000"></svg>
        </div>
        <div id='seg_div' class="col-8">
            segmentation
            <br/>
            <svg id="seg_svg" width="800" height="800"></svg>
        </div>
    </div>
</div>


<script type="text/javascript">
    let data_paths = {{ paths }};
    let seg_div = document.getElementById("seg_div"),
        table_div = document.getElementById("table_div");
    let seg_svg = d3.select("#seg_svg"),
        grid_vg = seg_svg.append("g").attr("transform", "translate(40,0)"),
        grid_hg = seg_svg.append("g").attr("transform", "translate(40,0)"),
        g = seg_svg.append("g").attr("transform", "translate(40,0)"),
        seg_width = Math.min(seg_div.clientWidth, 800)
    seg_svg.attr('width', seg_width)
    let num_timestep = 0

    let img_width = 1010,
        img_height = 1010;
    let seg_scale = d3.scaleLinear()
        .domain([0, img_width])
        .range([0, seg_width]);

    let main_dataset = {},
        comparative_datasets = [],
        candidate_datasets = [];

    let color_tableau = d3.scaleOrdinal(d3.schemeTableau10);

    function draw_grid() {

        let gridverticallines = d3.axisTop()
            .tickFormat("")
            .ticks(img_width / 10)
            .tickSize(-seg_width)
            .scale(seg_scale);

        let gridhorizontallines = d3.axisLeft()
            .tickFormat("")
            .ticks(img_height / 10)
            .tickSize(-seg_width)
            .scale(seg_scale);


        grid_vg
            .attr("class", "grid")
            .call(gridverticallines);
        grid_hg
            .attr("class", "grid")
            .call(gridhorizontallines);

        let t = 0
        let p = d3.line()
            .x(function (d) {
                return seg_scale(d[1]);
            }) // apply the x scale to the x data
            .y(function (d) {
                return seg_scale(d[0]);
            }) // apply the y scale to the y data
        d3.json("{% static 'celltrack_vis/data/celltracking_results/BF-C2DL-HSC/01_RES.json' %}").then(function (treeData) {
            g.append("path")
                .attr("class", "line") // attributes given one at a time
                .attr("d", p(treeData[0]["geometry"]["coordinates"][0])) // use the value of myline(xy) as the data, 'd'
                .style("stroke", color_tableau(0))
                .style('fill', color_tableau(0))
                .style("stroke-width", 2);
        })
    }


    function draw_table() {

        let table_svg = d3.select('#table_svg'),
            table_width = table_div.clientWidth,
            table_row_height = 20

        table_svg.attr('width', table_width)
            .attr('overflow', 'auto')

        let table_header = table_svg.append('g')
            .attr('class', 'header')
        table_header.append('text')
            .text('id')
            .attr('y', 20)


        table_header.append('text')
            .text('parent')
            .attr('y', 20)
            .attr('x', 30)

        d3.csv("{% static 'celltrack_vis/data/celltracking_results/BF-C2DL-HSC/01_RES/res_track.csv' %}").then(function (data) {
            table_svg.attr('height', data.length * table_row_height)
            let rows = table_svg.selectAll('.table_row')
                .data(data)
                .enter()
                .append('g')
                .attr('class', 'table_row')
                .attr('transform', (d, i) => 'translate(0,' + ((i + 2) * table_row_height) + ')')
            rows.append('text')
                .text(d => d['id'])

            rows.append('text')
                .text(d => d['parent'])
                .attr('x', 50)

            let table_cell_life_scale = d3.scaleLinear()
                .domain([0, 2000])
                .range([10, 100])

            rows.append('rect')
                .attr('x', d => 100 + table_cell_life_scale(d['birth']))
                .attr('y', -table_row_height / 2)
                .attr('width', d => table_cell_life_scale(d['death'] - d['birth']))
                .attr('fill', 'red')
                .attr('height', table_row_height / 2)
        })
        table_div.addEventListener('scroll', function () {
            table_header.node().setAttribute('transform', 'translate(0,' + this.scrollTop + ')');
        }, false)
    }

    let data_sets = [];

    function read_datasets() {
        for (let path of data_paths) {
            console.log('path', path)
            let p = "{% static 'celltrack_vis/data/celltracking_results/' %}" + path
            d3.json(p).then(function (data) {
                data_sets.push(data)
            })
            {#let dataset = {}#}
            {#dataset['name'] = path#}
            {#dataset['num_timestep'] = data_paths[path]#}
            {#dataset['num_cell'] = 0#}
            {#dataset['segmentation'] = null#}
            {#dataset['lineage'] = null#}

        }
    }

<<<<<<< HEAD
    function draw_menu() {

        for (let path in data_paths) {
            let p = "{% static 'celltrack_vis/data/celltracking_results/' %}" + path
            console.log(p, data_paths[path])
        }
        let menu_svg = d3.select('#menu_svg')
        let menu_rows = menu_svg.selectAll('g')
            .data(Object.keys(data_paths))
=======
    let gridverticallines = d3.axisTop()
        .tickFormat("")
        .ticks(img_width / 10)
        .tickSize(-seg_width)
        .scale(seg_scale);

    let gridhorizontallines = d3.axisLeft()
        .tickFormat("")
        .ticks(img_height / 10)
        .tickSize(-seg_width)
        .scale(seg_scale);


    grid_vg
        .attr("class", "grid")
        .call(gridverticallines);
    grid_hg
        .attr("class", "grid")
        .call(gridhorizontallines);

    let t = 0
    let p = d3.line()
        .x(function (d) {
            return seg_scale(d[1]);
        }) // apply the x scale to the x data
        .y(function (d) {
            return seg_scale(d[0]);
        }) // apply the y scale to the y data
    d3.json("{% static 'celltrack_vis/data/celltracking_results/BF-C2DL-HSC/01_RES.json' %}").then(function (treeData) {


        g.append("path")
            .attr("class", "line") // attributes given one at a time
            .attr("d", p(treeData[0]["geometry"]["coordinates"][0])) // use the value of myline(xy) as the data, 'd'
            .style("stroke", color_tableau(0))
            .style('fill', color_tableau(0))
            .style("stroke-width", 2);
    })


    let table_svg = d3.select('#table_svg'),
        table_width = table_div.clientWidth,
        table_row_height = 20

    table_svg.attr('width', table_width)
        .attr('overflow', 'auto')

    let table_header = table_svg.append('g')
        .attr('class', 'header')
    table_header.append('text')
        .text('id')
        .attr('y', 20)


    table_header.append('text')
        .text('parent')
        .attr('y', 20)
        .attr('x', 30)

    d3.csv("{% static 'celltrack_vis/data/celltracking_results/BF-C2DL-HSC/01_RES/res_track.csv' %}").then(function (data) {
        console.log(data)
        table_svg.attr('height', data.length * table_row_height)
        let rows = table_svg.selectAll('.table_row')
            .data(data)
>>>>>>> parent of b47ecd5 (polygonize)
            .enter()
            .append('g')
            .attr('transform', (d, i) => 'translate(0,' + (i * 20 + 20) + ')')
        menu_rows.append('rect')
            .attr('x', 0)
            .attr('y', -10)
            .attr('width', 10)
            .attr('height', 10)
            .attr('stroke', 'black')
        menu_rows.append('text')
            .text(d => d)
            .attr('x', 20)
        menu_rows.append('text')
            .text(d => data_paths[d])
            .attr('x', 220)

        // TODO : timestep change
        num_timestep = 1764
    }

    // timeline
    function draw_timeline() {
        let time_svg = d3.select('#time_svg')
    }

    read_datasets()
    draw_grid()
    draw_table()
    draw_menu()
    draw_timeline()


</script>
</body>
</html>